# Math::Symbolic::Parser::Yapp
# 
# Based on Parse::Yapp's calculator example

%left   ','
%left   '-' '+'
%left   '*' '/'
%left   NEG
%right  '^'


%%
exp:        NUM                 { $_[1] }
		|   FUNC '(' list ')'   { Math::Symbolic::Operator->new($_[1], @{$_[3]}) }
        |   VAR                 { $_[1] }
        |   exp '+' exp         { Math::Symbolic::Operator->new('+', $_[1], $_[3]) }
        |   exp '-' exp         { Math::Symbolic::Operator->new('-', $_[1], $_[3]) }
        |   exp '*' exp         { Math::Symbolic::Operator->new('*', $_[1], $_[3]) }
        |   exp '/' exp         { Math::Symbolic::Operator->new('/', $_[1], $_[3]) }
        |   '-' exp %prec NEG   { Math::Symbolic::Operator->new('neg', $_[2]) }
        |   exp '^' exp         { Math::Symbolic::Operator->new('^', $_[1], $_[3]) }
        |   '(' exp ')'         { $_[2] }
;

list:       exp ',' list		{ unshift @{$_[3]}, $_[1]; $_[3] }
        |   exp                 { [$_[1]] }
;
%%

use strict;
use warnings;
use Math::Symbolic qw//;
use constant DAT => 0;
use constant OP  => 1;

sub _Error {
        exists $_[0]->YYData->{ERRMSG}
    and do {
		my $x = $_[0]->YYData->{ERRMSG};
        delete $_[0]->YYData->{ERRMSG};
        die $x;
    };
    die "Syntax error in input string while parsing the following string: '".$_[0]->{USER}{INPUT}."'\n";
}

my $Num = qr/[+-]?(?=\d|\.\d)\d*(?:\.\d*)?(?:[Ee]([+-]?\d+))?/o;
my $Ident = qr/[a-zA-Z][a-zA-Z0-9_]*/o;
my $Op =  qr/\+|\-|\*|\/|\^/o;
my $Func = qr/log|partial_derivative|total_derivative|a?(?:sin|sinh|cos|cosh|tan|cot)/;
my $Unary = qr/\+|\-/o;

# This is a hack so we can hook into the new() method.
{
	no warnings; no strict;
	*real_new = \&new;
	*new = sub {
		goto &real_new;
	};
}

sub _Lexer {
    my($parser)=shift;

	my $data = $parser->{USER};

		pos($data->{INPUT}) < length($data->{INPUT})
    or  return('',undef);

    for ($data->{INPUT}) {
		if ($data->{STATE} == DAT) {
			if ($data->{INPUT} =~ /\G($Func)(?=\()/cgo) {
				return('FUNC', $1);
			}
			elsif ($data->{INPUT} =~ /\G($Ident)(?:\(($Ident(?:,$Ident)*)\))?/cgo) {
				$data->{STATE} = OP;
				if (defined $2) {
					return(
						'VAR',
						Math::Symbolic::Variable->new({name=>$1, signature=>[split /,/, $2]})
					);
				}
				else {
					return('VAR', Math::Symbolic::Variable->new({name=>$1}));
				}
			}
			elsif ($data->{INPUT} =~ /\G\(/cgo) {
				return('(', '(');
			}
			elsif ($data->{INPUT} =~ /\G($Num)/cgo) {
				$data->{STATE} = OP;
				return('NUM', Math::Symbolic::Constant->new($1));
			}
			elsif ($data->{INPUT} =~ /\G($Unary)/cgo) {
				return($1, $1);
			}
			else {
				my $pos = pos($data->{INPUT});
				die "Parse error at position $pos of string '$data->{INPUT}'.\nCould not find a suitable token while expecting data (identifier, function, number, etc.).";
			}
		}
		else { # $data->{STATE} == OP
			if ($data->{INPUT} =~ /\G\)/cgo) {
				return(')', ')');
			}
			elsif ($data->{INPUT} =~ /\G($Op)/cgo) {
				$data->{STATE} = DAT;
				return($1, $1);
			}
			elsif ($data->{INPUT} =~ /\G,/cgo) {
				$data->{STATE} = DAT;
				return(',', ',');
			}
			else {
				my $pos = pos($data->{INPUT});
				die "Parse error at position $pos of string '$data->{INPUT}'.\nCould not find a suitable token while expecting an operator (+, -, etc).";
			}
		}

    }
}

sub parse {
    my($self)=shift;
	my $in = shift;
	$in =~ s/\s+//g;
	$self->{USER}{STATE} = DAT;
	$self->{USER}{INPUT} = $in;
	pos($self->{USER}{INPUT}) = 0;
    return $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
}

sub parsedebug {
    my($self)=shift;
	my $in = shift;
	$in =~ s/\s+//g;
	$self->{USER}{STATE} = DAT;
	$self->{USER}{INPUT} = $in;
	pos($self->{USER}{INPUT}) = 0;
    return $self->YYParse( yydebug => 0x1F, yylex => \&_Lexer, yyerror => \&_Error );
}

1;
